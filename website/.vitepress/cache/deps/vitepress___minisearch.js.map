{"version":3,"file":"vitepress___minisearch.js","names":["node","child","key","promise","chunk","conditions","options","results","query","boosts","data"],"sources":["../../../../node_modules/.pnpm/minisearch@7.2.0/node_modules/minisearch/dist/es/index.js"],"sourcesContent":["/** @ignore */\nconst ENTRIES = 'ENTRIES';\n/** @ignore */\nconst KEYS = 'KEYS';\n/** @ignore */\nconst VALUES = 'VALUES';\n/** @ignore */\nconst LEAF = '';\n/**\n * @private\n */\nclass TreeIterator {\n    constructor(set, type) {\n        const node = set._tree;\n        const keys = Array.from(node.keys());\n        this.set = set;\n        this._type = type;\n        this._path = keys.length > 0 ? [{ node, keys }] : [];\n    }\n    next() {\n        const value = this.dive();\n        this.backtrack();\n        return value;\n    }\n    dive() {\n        if (this._path.length === 0) {\n            return { done: true, value: undefined };\n        }\n        const { node, keys } = last$1(this._path);\n        if (last$1(keys) === LEAF) {\n            return { done: false, value: this.result() };\n        }\n        const child = node.get(last$1(keys));\n        this._path.push({ node: child, keys: Array.from(child.keys()) });\n        return this.dive();\n    }\n    backtrack() {\n        if (this._path.length === 0) {\n            return;\n        }\n        const keys = last$1(this._path).keys;\n        keys.pop();\n        if (keys.length > 0) {\n            return;\n        }\n        this._path.pop();\n        this.backtrack();\n    }\n    key() {\n        return this.set._prefix + this._path\n            .map(({ keys }) => last$1(keys))\n            .filter(key => key !== LEAF)\n            .join('');\n    }\n    value() {\n        return last$1(this._path).node.get(LEAF);\n    }\n    result() {\n        switch (this._type) {\n            case VALUES: return this.value();\n            case KEYS: return this.key();\n            default: return [this.key(), this.value()];\n        }\n    }\n    [Symbol.iterator]() {\n        return this;\n    }\n}\nconst last$1 = (array) => {\n    return array[array.length - 1];\n};\n\n/* eslint-disable no-labels */\n/**\n * @ignore\n */\nconst fuzzySearch = (node, query, maxDistance) => {\n    const results = new Map();\n    if (query === undefined)\n        return results;\n    // Number of columns in the Levenshtein matrix.\n    const n = query.length + 1;\n    // Matching terms can never be longer than N + maxDistance.\n    const m = n + maxDistance;\n    // Fill first matrix row and column with numbers: 0 1 2 3 ...\n    const matrix = new Uint8Array(m * n).fill(maxDistance + 1);\n    for (let j = 0; j < n; ++j)\n        matrix[j] = j;\n    for (let i = 1; i < m; ++i)\n        matrix[i * n] = i;\n    recurse(node, query, maxDistance, results, matrix, 1, n, '');\n    return results;\n};\n// Modified version of http://stevehanov.ca/blog/?id=114\n// This builds a Levenshtein matrix for a given query and continuously updates\n// it for nodes in the radix tree that fall within the given maximum edit\n// distance. Keeping the same matrix around is beneficial especially for larger\n// edit distances.\n//\n//           k   a   t   e   <-- query\n//       0   1   2   3   4\n//   c   1   1   2   3   4\n//   a   2   2   1   2   3\n//   t   3   3   2   1  [2]  <-- edit distance\n//   ^\n//   ^ term in radix tree, rows are added and removed as needed\nconst recurse = (node, query, maxDistance, results, matrix, m, n, prefix) => {\n    const offset = m * n;\n    key: for (const key of node.keys()) {\n        if (key === LEAF) {\n            // We've reached a leaf node. Check if the edit distance acceptable and\n            // store the result if it is.\n            const distance = matrix[offset - 1];\n            if (distance <= maxDistance) {\n                results.set(prefix, [node.get(key), distance]);\n            }\n        }\n        else {\n            // Iterate over all characters in the key. Update the Levenshtein matrix\n            // and check if the minimum distance in the last row is still within the\n            // maximum edit distance. If it is, we can recurse over all child nodes.\n            let i = m;\n            for (let pos = 0; pos < key.length; ++pos, ++i) {\n                const char = key[pos];\n                const thisRowOffset = n * i;\n                const prevRowOffset = thisRowOffset - n;\n                // Set the first column based on the previous row, and initialize the\n                // minimum distance in the current row.\n                let minDistance = matrix[thisRowOffset];\n                const jmin = Math.max(0, i - maxDistance - 1);\n                const jmax = Math.min(n - 1, i + maxDistance);\n                // Iterate over remaining columns (characters in the query).\n                for (let j = jmin; j < jmax; ++j) {\n                    const different = char !== query[j];\n                    // It might make sense to only read the matrix positions used for\n                    // deletion/insertion if the characters are different. But we want to\n                    // avoid conditional reads for performance reasons.\n                    const rpl = matrix[prevRowOffset + j] + +different;\n                    const del = matrix[prevRowOffset + j + 1] + 1;\n                    const ins = matrix[thisRowOffset + j] + 1;\n                    const dist = matrix[thisRowOffset + j + 1] = Math.min(rpl, del, ins);\n                    if (dist < minDistance)\n                        minDistance = dist;\n                }\n                // Because distance will never decrease, we can stop. There will be no\n                // matching child nodes.\n                if (minDistance > maxDistance) {\n                    continue key;\n                }\n            }\n            recurse(node.get(key), query, maxDistance, results, matrix, i, n, prefix + key);\n        }\n    }\n};\n\n/* eslint-disable no-labels */\n/**\n * A class implementing the same interface as a standard JavaScript\n * [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n * with string keys, but adding support for efficiently searching entries with\n * prefix or fuzzy search. This class is used internally by {@link MiniSearch}\n * as the inverted index data structure. The implementation is a radix tree\n * (compressed prefix tree).\n *\n * Since this class can be of general utility beyond _MiniSearch_, it is\n * exported by the `minisearch` package and can be imported (or required) as\n * `minisearch/SearchableMap`.\n *\n * @typeParam T  The type of the values stored in the map.\n */\nclass SearchableMap {\n    /**\n     * The constructor is normally called without arguments, creating an empty\n     * map. In order to create a {@link SearchableMap} from an iterable or from an\n     * object, check {@link SearchableMap.from} and {@link\n     * SearchableMap.fromObject}.\n     *\n     * The constructor arguments are for internal use, when creating derived\n     * mutable views of a map at a prefix.\n     */\n    constructor(tree = new Map(), prefix = '') {\n        this._size = undefined;\n        this._tree = tree;\n        this._prefix = prefix;\n    }\n    /**\n     * Creates and returns a mutable view of this {@link SearchableMap},\n     * containing only entries that share the given prefix.\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * let map = new SearchableMap()\n     * map.set(\"unicorn\", 1)\n     * map.set(\"universe\", 2)\n     * map.set(\"university\", 3)\n     * map.set(\"unique\", 4)\n     * map.set(\"hello\", 5)\n     *\n     * let uni = map.atPrefix(\"uni\")\n     * uni.get(\"unique\") // => 4\n     * uni.get(\"unicorn\") // => 1\n     * uni.get(\"hello\") // => undefined\n     *\n     * let univer = map.atPrefix(\"univer\")\n     * univer.get(\"unique\") // => undefined\n     * univer.get(\"universe\") // => 2\n     * univer.get(\"university\") // => 3\n     * ```\n     *\n     * @param prefix  The prefix\n     * @return A {@link SearchableMap} representing a mutable view of the original\n     * Map at the given prefix\n     */\n    atPrefix(prefix) {\n        if (!prefix.startsWith(this._prefix)) {\n            throw new Error('Mismatched prefix');\n        }\n        const [node, path] = trackDown(this._tree, prefix.slice(this._prefix.length));\n        if (node === undefined) {\n            const [parentNode, key] = last(path);\n            for (const k of parentNode.keys()) {\n                if (k !== LEAF && k.startsWith(key)) {\n                    const node = new Map();\n                    node.set(k.slice(key.length), parentNode.get(k));\n                    return new SearchableMap(node, prefix);\n                }\n            }\n        }\n        return new SearchableMap(node, prefix);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear\n     */\n    clear() {\n        this._size = undefined;\n        this._tree.clear();\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete\n     * @param key  Key to delete\n     */\n    delete(key) {\n        this._size = undefined;\n        return remove(this._tree, key);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/entries\n     * @return An iterator iterating through `[key, value]` entries.\n     */\n    entries() {\n        return new TreeIterator(this, ENTRIES);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach\n     * @param fn  Iteration function\n     */\n    forEach(fn) {\n        for (const [key, value] of this) {\n            fn(key, value, this);\n        }\n    }\n    /**\n     * Returns a Map of all the entries that have a key within the given edit\n     * distance from the search key. The keys of the returned Map are the matching\n     * keys, while the values are two-element arrays where the first element is\n     * the value associated to the key, and the second is the edit distance of the\n     * key to the search key.\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * let map = new SearchableMap()\n     * map.set('hello', 'world')\n     * map.set('hell', 'yeah')\n     * map.set('ciao', 'mondo')\n     *\n     * // Get all entries that match the key 'hallo' with a maximum edit distance of 2\n     * map.fuzzyGet('hallo', 2)\n     * // => Map(2) { 'hello' => ['world', 1], 'hell' => ['yeah', 2] }\n     *\n     * // In the example, the \"hello\" key has value \"world\" and edit distance of 1\n     * // (change \"e\" to \"a\"), the key \"hell\" has value \"yeah\" and edit distance of 2\n     * // (change \"e\" to \"a\", delete \"o\")\n     * ```\n     *\n     * @param key  The search key\n     * @param maxEditDistance  The maximum edit distance (Levenshtein)\n     * @return A Map of the matching keys to their value and edit distance\n     */\n    fuzzyGet(key, maxEditDistance) {\n        return fuzzySearch(this._tree, key, maxEditDistance);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get\n     * @param key  Key to get\n     * @return Value associated to the key, or `undefined` if the key is not\n     * found.\n     */\n    get(key) {\n        const node = lookup(this._tree, key);\n        return node !== undefined ? node.get(LEAF) : undefined;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has\n     * @param key  Key\n     * @return True if the key is in the map, false otherwise\n     */\n    has(key) {\n        const node = lookup(this._tree, key);\n        return node !== undefined && node.has(LEAF);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/keys\n     * @return An `Iterable` iterating through keys\n     */\n    keys() {\n        return new TreeIterator(this, KEYS);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set\n     * @param key  Key to set\n     * @param value  Value to associate to the key\n     * @return The {@link SearchableMap} itself, to allow chaining\n     */\n    set(key, value) {\n        if (typeof key !== 'string') {\n            throw new Error('key must be a string');\n        }\n        this._size = undefined;\n        const node = createPath(this._tree, key);\n        node.set(LEAF, value);\n        return this;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size\n     */\n    get size() {\n        if (this._size) {\n            return this._size;\n        }\n        /** @ignore */\n        this._size = 0;\n        const iter = this.entries();\n        while (!iter.next().done)\n            this._size += 1;\n        return this._size;\n    }\n    /**\n     * Updates the value at the given key using the provided function. The function\n     * is called with the current value at the key, and its return value is used as\n     * the new value to be set.\n     *\n     * ### Example:\n     *\n     * ```javascript\n     * // Increment the current value by one\n     * searchableMap.update('somekey', (currentValue) => currentValue == null ? 0 : currentValue + 1)\n     * ```\n     *\n     * If the value at the given key is or will be an object, it might not require\n     * re-assignment. In that case it is better to use `fetch()`, because it is\n     * faster.\n     *\n     * @param key  The key to update\n     * @param fn  The function used to compute the new value from the current one\n     * @return The {@link SearchableMap} itself, to allow chaining\n     */\n    update(key, fn) {\n        if (typeof key !== 'string') {\n            throw new Error('key must be a string');\n        }\n        this._size = undefined;\n        const node = createPath(this._tree, key);\n        node.set(LEAF, fn(node.get(LEAF)));\n        return this;\n    }\n    /**\n     * Fetches the value of the given key. If the value does not exist, calls the\n     * given function to create a new value, which is inserted at the given key\n     * and subsequently returned.\n     *\n     * ### Example:\n     *\n     * ```javascript\n     * const map = searchableMap.fetch('somekey', () => new Map())\n     * map.set('foo', 'bar')\n     * ```\n     *\n     * @param key  The key to update\n     * @param initial  A function that creates a new value if the key does not exist\n     * @return The existing or new value at the given key\n     */\n    fetch(key, initial) {\n        if (typeof key !== 'string') {\n            throw new Error('key must be a string');\n        }\n        this._size = undefined;\n        const node = createPath(this._tree, key);\n        let value = node.get(LEAF);\n        if (value === undefined) {\n            node.set(LEAF, value = initial());\n        }\n        return value;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/values\n     * @return An `Iterable` iterating through values.\n     */\n    values() {\n        return new TreeIterator(this, VALUES);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * Creates a {@link SearchableMap} from an `Iterable` of entries\n     *\n     * @param entries  Entries to be inserted in the {@link SearchableMap}\n     * @return A new {@link SearchableMap} with the given entries\n     */\n    static from(entries) {\n        const tree = new SearchableMap();\n        for (const [key, value] of entries) {\n            tree.set(key, value);\n        }\n        return tree;\n    }\n    /**\n     * Creates a {@link SearchableMap} from the iterable properties of a JavaScript object\n     *\n     * @param object  Object of entries for the {@link SearchableMap}\n     * @return A new {@link SearchableMap} with the given entries\n     */\n    static fromObject(object) {\n        return SearchableMap.from(Object.entries(object));\n    }\n}\nconst trackDown = (tree, key, path = []) => {\n    if (key.length === 0 || tree == null) {\n        return [tree, path];\n    }\n    for (const k of tree.keys()) {\n        if (k !== LEAF && key.startsWith(k)) {\n            path.push([tree, k]); // performance: update in place\n            return trackDown(tree.get(k), key.slice(k.length), path);\n        }\n    }\n    path.push([tree, key]); // performance: update in place\n    return trackDown(undefined, '', path);\n};\nconst lookup = (tree, key) => {\n    if (key.length === 0 || tree == null) {\n        return tree;\n    }\n    for (const k of tree.keys()) {\n        if (k !== LEAF && key.startsWith(k)) {\n            return lookup(tree.get(k), key.slice(k.length));\n        }\n    }\n};\n// Create a path in the radix tree for the given key, and returns the deepest\n// node. This function is in the hot path for indexing. It avoids unnecessary\n// string operations and recursion for performance.\nconst createPath = (node, key) => {\n    const keyLength = key.length;\n    outer: for (let pos = 0; node && pos < keyLength;) {\n        for (const k of node.keys()) {\n            // Check whether this key is a candidate: the first characters must match.\n            if (k !== LEAF && key[pos] === k[0]) {\n                const len = Math.min(keyLength - pos, k.length);\n                // Advance offset to the point where key and k no longer match.\n                let offset = 1;\n                while (offset < len && key[pos + offset] === k[offset])\n                    ++offset;\n                const child = node.get(k);\n                if (offset === k.length) {\n                    // The existing key is shorter than the key we need to create.\n                    node = child;\n                }\n                else {\n                    // Partial match: we need to insert an intermediate node to contain\n                    // both the existing subtree and the new node.\n                    const intermediate = new Map();\n                    intermediate.set(k.slice(offset), child);\n                    node.set(key.slice(pos, pos + offset), intermediate);\n                    node.delete(k);\n                    node = intermediate;\n                }\n                pos += offset;\n                continue outer;\n            }\n        }\n        // Create a final child node to contain the final suffix of the key.\n        const child = new Map();\n        node.set(key.slice(pos), child);\n        return child;\n    }\n    return node;\n};\nconst remove = (tree, key) => {\n    const [node, path] = trackDown(tree, key);\n    if (node === undefined) {\n        return;\n    }\n    node.delete(LEAF);\n    if (node.size === 0) {\n        cleanup(path);\n    }\n    else if (node.size === 1) {\n        const [key, value] = node.entries().next().value;\n        merge(path, key, value);\n    }\n};\nconst cleanup = (path) => {\n    if (path.length === 0) {\n        return;\n    }\n    const [node, key] = last(path);\n    node.delete(key);\n    if (node.size === 0) {\n        cleanup(path.slice(0, -1));\n    }\n    else if (node.size === 1) {\n        const [key, value] = node.entries().next().value;\n        if (key !== LEAF) {\n            merge(path.slice(0, -1), key, value);\n        }\n    }\n};\nconst merge = (path, key, value) => {\n    if (path.length === 0) {\n        return;\n    }\n    const [node, nodeKey] = last(path);\n    node.set(nodeKey + key, value);\n    node.delete(nodeKey);\n};\nconst last = (array) => {\n    return array[array.length - 1];\n};\n\nconst OR = 'or';\nconst AND = 'and';\nconst AND_NOT = 'and_not';\n/**\n * {@link MiniSearch} is the main entrypoint class, implementing a full-text\n * search engine in memory.\n *\n * @typeParam T  The type of the documents being indexed.\n *\n * ### Basic example:\n *\n * ```javascript\n * const documents = [\n *   {\n *     id: 1,\n *     title: 'Moby Dick',\n *     text: 'Call me Ishmael. Some years ago...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 2,\n *     title: 'Zen and the Art of Motorcycle Maintenance',\n *     text: 'I can see by my watch...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 3,\n *     title: 'Neuromancer',\n *     text: 'The sky above the port was...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 4,\n *     title: 'Zen and the Art of Archery',\n *     text: 'At first sight it must seem...',\n *     category: 'non-fiction'\n *   },\n *   // ...and more\n * ]\n *\n * // Create a search engine that indexes the 'title' and 'text' fields for\n * // full-text search. Search results will include 'title' and 'category' (plus the\n * // id field, that is always stored and returned)\n * const miniSearch = new MiniSearch({\n *   fields: ['title', 'text'],\n *   storeFields: ['title', 'category']\n * })\n *\n * // Add documents to the index\n * miniSearch.addAll(documents)\n *\n * // Search for documents:\n * let results = miniSearch.search('zen art motorcycle')\n * // => [\n * //   { id: 2, title: 'Zen and the Art of Motorcycle Maintenance', category: 'fiction', score: 2.77258 },\n * //   { id: 4, title: 'Zen and the Art of Archery', category: 'non-fiction', score: 1.38629 }\n * // ]\n * ```\n */\nclass MiniSearch {\n    /**\n     * @param options  Configuration options\n     *\n     * ### Examples:\n     *\n     * ```javascript\n     * // Create a search engine that indexes the 'title' and 'text' fields of your\n     * // documents:\n     * const miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n     * ```\n     *\n     * ### ID Field:\n     *\n     * ```javascript\n     * // Your documents are assumed to include a unique 'id' field, but if you want\n     * // to use a different field for document identification, you can set the\n     * // 'idField' option:\n     * const miniSearch = new MiniSearch({ idField: 'key', fields: ['title', 'text'] })\n     * ```\n     *\n     * ### Options and defaults:\n     *\n     * ```javascript\n     * // The full set of options (here with their default value) is:\n     * const miniSearch = new MiniSearch({\n     *   // idField: field that uniquely identifies a document\n     *   idField: 'id',\n     *\n     *   // extractField: function used to get the value of a field in a document.\n     *   // By default, it assumes the document is a flat object with field names as\n     *   // property keys and field values as string property values, but custom logic\n     *   // can be implemented by setting this option to a custom extractor function.\n     *   extractField: (document, fieldName) => document[fieldName],\n     *\n     *   // tokenize: function used to split fields into individual terms. By\n     *   // default, it is also used to tokenize search queries, unless a specific\n     *   // `tokenize` search option is supplied. When tokenizing an indexed field,\n     *   // the field name is passed as the second argument.\n     *   tokenize: (string, _fieldName) => string.split(SPACE_OR_PUNCTUATION),\n     *\n     *   // processTerm: function used to process each tokenized term before\n     *   // indexing. It can be used for stemming and normalization. Return a falsy\n     *   // value in order to discard a term. By default, it is also used to process\n     *   // search queries, unless a specific `processTerm` option is supplied as a\n     *   // search option. When processing a term from a indexed field, the field\n     *   // name is passed as the second argument.\n     *   processTerm: (term, _fieldName) => term.toLowerCase(),\n     *\n     *   // searchOptions: default search options, see the `search` method for\n     *   // details\n     *   searchOptions: undefined,\n     *\n     *   // fields: document fields to be indexed. Mandatory, but not set by default\n     *   fields: undefined\n     *\n     *   // storeFields: document fields to be stored and returned as part of the\n     *   // search results.\n     *   storeFields: []\n     * })\n     * ```\n     */\n    constructor(options) {\n        if ((options === null || options === void 0 ? void 0 : options.fields) == null) {\n            throw new Error('MiniSearch: option \"fields\" must be provided');\n        }\n        const autoVacuum = (options.autoVacuum == null || options.autoVacuum === true) ? defaultAutoVacuumOptions : options.autoVacuum;\n        this._options = {\n            ...defaultOptions,\n            ...options,\n            autoVacuum,\n            searchOptions: { ...defaultSearchOptions, ...(options.searchOptions || {}) },\n            autoSuggestOptions: { ...defaultAutoSuggestOptions, ...(options.autoSuggestOptions || {}) }\n        };\n        this._index = new SearchableMap();\n        this._documentCount = 0;\n        this._documentIds = new Map();\n        this._idToShortId = new Map();\n        // Fields are defined during initialization, don't change, are few in\n        // number, rarely need iterating over, and have string keys. Therefore in\n        // this case an object is a better candidate than a Map to store the mapping\n        // from field key to ID.\n        this._fieldIds = {};\n        this._fieldLength = new Map();\n        this._avgFieldLength = [];\n        this._nextId = 0;\n        this._storedFields = new Map();\n        this._dirtCount = 0;\n        this._currentVacuum = null;\n        this._enqueuedVacuum = null;\n        this._enqueuedVacuumConditions = defaultVacuumConditions;\n        this.addFields(this._options.fields);\n    }\n    /**\n     * Adds a document to the index\n     *\n     * @param document  The document to be indexed\n     */\n    add(document) {\n        const { extractField, stringifyField, tokenize, processTerm, fields, idField } = this._options;\n        const id = extractField(document, idField);\n        if (id == null) {\n            throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`);\n        }\n        if (this._idToShortId.has(id)) {\n            throw new Error(`MiniSearch: duplicate ID ${id}`);\n        }\n        const shortDocumentId = this.addDocumentId(id);\n        this.saveStoredFields(shortDocumentId, document);\n        for (const field of fields) {\n            const fieldValue = extractField(document, field);\n            if (fieldValue == null)\n                continue;\n            const tokens = tokenize(stringifyField(fieldValue, field), field);\n            const fieldId = this._fieldIds[field];\n            const uniqueTerms = new Set(tokens).size;\n            this.addFieldLength(shortDocumentId, fieldId, this._documentCount - 1, uniqueTerms);\n            for (const term of tokens) {\n                const processedTerm = processTerm(term, field);\n                if (Array.isArray(processedTerm)) {\n                    for (const t of processedTerm) {\n                        this.addTerm(fieldId, shortDocumentId, t);\n                    }\n                }\n                else if (processedTerm) {\n                    this.addTerm(fieldId, shortDocumentId, processedTerm);\n                }\n            }\n        }\n    }\n    /**\n     * Adds all the given documents to the index\n     *\n     * @param documents  An array of documents to be indexed\n     */\n    addAll(documents) {\n        for (const document of documents)\n            this.add(document);\n    }\n    /**\n     * Adds all the given documents to the index asynchronously.\n     *\n     * Returns a promise that resolves (to `undefined`) when the indexing is done.\n     * This method is useful when index many documents, to avoid blocking the main\n     * thread. The indexing is performed asynchronously and in chunks.\n     *\n     * @param documents  An array of documents to be indexed\n     * @param options  Configuration options\n     * @return A promise resolving to `undefined` when the indexing is done\n     */\n    addAllAsync(documents, options = {}) {\n        const { chunkSize = 10 } = options;\n        const acc = { chunk: [], promise: Promise.resolve() };\n        const { chunk, promise } = documents.reduce(({ chunk, promise }, document, i) => {\n            chunk.push(document);\n            if ((i + 1) % chunkSize === 0) {\n                return {\n                    chunk: [],\n                    promise: promise\n                        .then(() => new Promise(resolve => setTimeout(resolve, 0)))\n                        .then(() => this.addAll(chunk))\n                };\n            }\n            else {\n                return { chunk, promise };\n            }\n        }, acc);\n        return promise.then(() => this.addAll(chunk));\n    }\n    /**\n     * Removes the given document from the index.\n     *\n     * The document to remove must NOT have changed between indexing and removal,\n     * otherwise the index will be corrupted.\n     *\n     * This method requires passing the full document to be removed (not just the\n     * ID), and immediately removes the document from the inverted index, allowing\n     * memory to be released. A convenient alternative is {@link\n     * MiniSearch#discard}, which needs only the document ID, and has the same\n     * visible effect, but delays cleaning up the index until the next vacuuming.\n     *\n     * @param document  The document to be removed\n     */\n    remove(document) {\n        const { tokenize, processTerm, extractField, stringifyField, fields, idField } = this._options;\n        const id = extractField(document, idField);\n        if (id == null) {\n            throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`);\n        }\n        const shortId = this._idToShortId.get(id);\n        if (shortId == null) {\n            throw new Error(`MiniSearch: cannot remove document with ID ${id}: it is not in the index`);\n        }\n        for (const field of fields) {\n            const fieldValue = extractField(document, field);\n            if (fieldValue == null)\n                continue;\n            const tokens = tokenize(stringifyField(fieldValue, field), field);\n            const fieldId = this._fieldIds[field];\n            const uniqueTerms = new Set(tokens).size;\n            this.removeFieldLength(shortId, fieldId, this._documentCount, uniqueTerms);\n            for (const term of tokens) {\n                const processedTerm = processTerm(term, field);\n                if (Array.isArray(processedTerm)) {\n                    for (const t of processedTerm) {\n                        this.removeTerm(fieldId, shortId, t);\n                    }\n                }\n                else if (processedTerm) {\n                    this.removeTerm(fieldId, shortId, processedTerm);\n                }\n            }\n        }\n        this._storedFields.delete(shortId);\n        this._documentIds.delete(shortId);\n        this._idToShortId.delete(id);\n        this._fieldLength.delete(shortId);\n        this._documentCount -= 1;\n    }\n    /**\n     * Removes all the given documents from the index. If called with no arguments,\n     * it removes _all_ documents from the index.\n     *\n     * @param documents  The documents to be removed. If this argument is omitted,\n     * all documents are removed. Note that, for removing all documents, it is\n     * more efficient to call this method with no arguments than to pass all\n     * documents.\n     */\n    removeAll(documents) {\n        if (documents) {\n            for (const document of documents)\n                this.remove(document);\n        }\n        else if (arguments.length > 0) {\n            throw new Error('Expected documents to be present. Omit the argument to remove all documents.');\n        }\n        else {\n            this._index = new SearchableMap();\n            this._documentCount = 0;\n            this._documentIds = new Map();\n            this._idToShortId = new Map();\n            this._fieldLength = new Map();\n            this._avgFieldLength = [];\n            this._storedFields = new Map();\n            this._nextId = 0;\n        }\n    }\n    /**\n     * Discards the document with the given ID, so it won't appear in search results\n     *\n     * It has the same visible effect of {@link MiniSearch.remove} (both cause the\n     * document to stop appearing in searches), but a different effect on the\n     * internal data structures:\n     *\n     *   - {@link MiniSearch#remove} requires passing the full document to be\n     *   removed as argument, and removes it from the inverted index immediately.\n     *\n     *   - {@link MiniSearch#discard} instead only needs the document ID, and\n     *   works by marking the current version of the document as discarded, so it\n     *   is immediately ignored by searches. This is faster and more convenient\n     *   than {@link MiniSearch#remove}, but the index is not immediately\n     *   modified. To take care of that, vacuuming is performed after a certain\n     *   number of documents are discarded, cleaning up the index and allowing\n     *   memory to be released.\n     *\n     * After discarding a document, it is possible to re-add a new version, and\n     * only the new version will appear in searches. In other words, discarding\n     * and re-adding a document works exactly like removing and re-adding it. The\n     * {@link MiniSearch.replace} method can also be used to replace a document\n     * with a new version.\n     *\n     * #### Details about vacuuming\n     *\n     * Repetite calls to this method would leave obsolete document references in\n     * the index, invisible to searches. Two mechanisms take care of cleaning up:\n     * clean up during search, and vacuuming.\n     *\n     *   - Upon search, whenever a discarded ID is found (and ignored for the\n     *   results), references to the discarded document are removed from the\n     *   inverted index entries for the search terms. This ensures that subsequent\n     *   searches for the same terms do not need to skip these obsolete references\n     *   again.\n     *\n     *   - In addition, vacuuming is performed automatically by default (see the\n     *   `autoVacuum` field in {@link Options}) after a certain number of\n     *   documents are discarded. Vacuuming traverses all terms in the index,\n     *   cleaning up all references to discarded documents. Vacuuming can also be\n     *   triggered manually by calling {@link MiniSearch#vacuum}.\n     *\n     * @param id  The ID of the document to be discarded\n     */\n    discard(id) {\n        const shortId = this._idToShortId.get(id);\n        if (shortId == null) {\n            throw new Error(`MiniSearch: cannot discard document with ID ${id}: it is not in the index`);\n        }\n        this._idToShortId.delete(id);\n        this._documentIds.delete(shortId);\n        this._storedFields.delete(shortId);\n        (this._fieldLength.get(shortId) || []).forEach((fieldLength, fieldId) => {\n            this.removeFieldLength(shortId, fieldId, this._documentCount, fieldLength);\n        });\n        this._fieldLength.delete(shortId);\n        this._documentCount -= 1;\n        this._dirtCount += 1;\n        this.maybeAutoVacuum();\n    }\n    maybeAutoVacuum() {\n        if (this._options.autoVacuum === false) {\n            return;\n        }\n        const { minDirtFactor, minDirtCount, batchSize, batchWait } = this._options.autoVacuum;\n        this.conditionalVacuum({ batchSize, batchWait }, { minDirtCount, minDirtFactor });\n    }\n    /**\n     * Discards the documents with the given IDs, so they won't appear in search\n     * results\n     *\n     * It is equivalent to calling {@link MiniSearch#discard} for all the given\n     * IDs, but with the optimization of triggering at most one automatic\n     * vacuuming at the end.\n     *\n     * Note: to remove all documents from the index, it is faster and more\n     * convenient to call {@link MiniSearch.removeAll} with no argument, instead\n     * of passing all IDs to this method.\n     */\n    discardAll(ids) {\n        const autoVacuum = this._options.autoVacuum;\n        try {\n            this._options.autoVacuum = false;\n            for (const id of ids) {\n                this.discard(id);\n            }\n        }\n        finally {\n            this._options.autoVacuum = autoVacuum;\n        }\n        this.maybeAutoVacuum();\n    }\n    /**\n     * It replaces an existing document with the given updated version\n     *\n     * It works by discarding the current version and adding the updated one, so\n     * it is functionally equivalent to calling {@link MiniSearch#discard}\n     * followed by {@link MiniSearch#add}. The ID of the updated document should\n     * be the same as the original one.\n     *\n     * Since it uses {@link MiniSearch#discard} internally, this method relies on\n     * vacuuming to clean up obsolete document references from the index, allowing\n     * memory to be released (see {@link MiniSearch#discard}).\n     *\n     * @param updatedDocument  The updated document to replace the old version\n     * with\n     */\n    replace(updatedDocument) {\n        const { idField, extractField } = this._options;\n        const id = extractField(updatedDocument, idField);\n        this.discard(id);\n        this.add(updatedDocument);\n    }\n    /**\n     * Triggers a manual vacuuming, cleaning up references to discarded documents\n     * from the inverted index\n     *\n     * Vacuuming is only useful for applications that use the {@link\n     * MiniSearch#discard} or {@link MiniSearch#replace} methods.\n     *\n     * By default, vacuuming is performed automatically when needed (controlled by\n     * the `autoVacuum` field in {@link Options}), so there is usually no need to\n     * call this method, unless one wants to make sure to perform vacuuming at a\n     * specific moment.\n     *\n     * Vacuuming traverses all terms in the inverted index in batches, and cleans\n     * up references to discarded documents from the posting list, allowing memory\n     * to be released.\n     *\n     * The method takes an optional object as argument with the following keys:\n     *\n     *   - `batchSize`: the size of each batch (1000 by default)\n     *\n     *   - `batchWait`: the number of milliseconds to wait between batches (10 by\n     *   default)\n     *\n     * On large indexes, vacuuming could have a non-negligible cost: batching\n     * avoids blocking the thread for long, diluting this cost so that it is not\n     * negatively affecting the application. Nonetheless, this method should only\n     * be called when necessary, and relying on automatic vacuuming is usually\n     * better.\n     *\n     * It returns a promise that resolves (to undefined) when the clean up is\n     * completed. If vacuuming is already ongoing at the time this method is\n     * called, a new one is enqueued immediately after the ongoing one, and a\n     * corresponding promise is returned. However, no more than one vacuuming is\n     * enqueued on top of the ongoing one, even if this method is called more\n     * times (enqueuing multiple ones would be useless).\n     *\n     * @param options  Configuration options for the batch size and delay. See\n     * {@link VacuumOptions}.\n     */\n    vacuum(options = {}) {\n        return this.conditionalVacuum(options);\n    }\n    conditionalVacuum(options, conditions) {\n        // If a vacuum is already ongoing, schedule another as soon as it finishes,\n        // unless there's already one enqueued. If one was already enqueued, do not\n        // enqueue another on top, but make sure that the conditions are the\n        // broadest.\n        if (this._currentVacuum) {\n            this._enqueuedVacuumConditions = this._enqueuedVacuumConditions && conditions;\n            if (this._enqueuedVacuum != null) {\n                return this._enqueuedVacuum;\n            }\n            this._enqueuedVacuum = this._currentVacuum.then(() => {\n                const conditions = this._enqueuedVacuumConditions;\n                this._enqueuedVacuumConditions = defaultVacuumConditions;\n                return this.performVacuuming(options, conditions);\n            });\n            return this._enqueuedVacuum;\n        }\n        if (this.vacuumConditionsMet(conditions) === false) {\n            return Promise.resolve();\n        }\n        this._currentVacuum = this.performVacuuming(options);\n        return this._currentVacuum;\n    }\n    async performVacuuming(options, conditions) {\n        const initialDirtCount = this._dirtCount;\n        if (this.vacuumConditionsMet(conditions)) {\n            const batchSize = options.batchSize || defaultVacuumOptions.batchSize;\n            const batchWait = options.batchWait || defaultVacuumOptions.batchWait;\n            let i = 1;\n            for (const [term, fieldsData] of this._index) {\n                for (const [fieldId, fieldIndex] of fieldsData) {\n                    for (const [shortId] of fieldIndex) {\n                        if (this._documentIds.has(shortId)) {\n                            continue;\n                        }\n                        if (fieldIndex.size <= 1) {\n                            fieldsData.delete(fieldId);\n                        }\n                        else {\n                            fieldIndex.delete(shortId);\n                        }\n                    }\n                }\n                if (this._index.get(term).size === 0) {\n                    this._index.delete(term);\n                }\n                if (i % batchSize === 0) {\n                    await new Promise((resolve) => setTimeout(resolve, batchWait));\n                }\n                i += 1;\n            }\n            this._dirtCount -= initialDirtCount;\n        }\n        // Make the next lines always async, so they execute after this function returns\n        await null;\n        this._currentVacuum = this._enqueuedVacuum;\n        this._enqueuedVacuum = null;\n    }\n    vacuumConditionsMet(conditions) {\n        if (conditions == null) {\n            return true;\n        }\n        let { minDirtCount, minDirtFactor } = conditions;\n        minDirtCount = minDirtCount || defaultAutoVacuumOptions.minDirtCount;\n        minDirtFactor = minDirtFactor || defaultAutoVacuumOptions.minDirtFactor;\n        return this.dirtCount >= minDirtCount && this.dirtFactor >= minDirtFactor;\n    }\n    /**\n     * Is `true` if a vacuuming operation is ongoing, `false` otherwise\n     */\n    get isVacuuming() {\n        return this._currentVacuum != null;\n    }\n    /**\n     * The number of documents discarded since the most recent vacuuming\n     */\n    get dirtCount() {\n        return this._dirtCount;\n    }\n    /**\n     * A number between 0 and 1 giving an indication about the proportion of\n     * documents that are discarded, and can therefore be cleaned up by vacuuming.\n     * A value close to 0 means that the index is relatively clean, while a higher\n     * value means that the index is relatively dirty, and vacuuming could release\n     * memory.\n     */\n    get dirtFactor() {\n        return this._dirtCount / (1 + this._documentCount + this._dirtCount);\n    }\n    /**\n     * Returns `true` if a document with the given ID is present in the index and\n     * available for search, `false` otherwise\n     *\n     * @param id  The document ID\n     */\n    has(id) {\n        return this._idToShortId.has(id);\n    }\n    /**\n     * Returns the stored fields (as configured in the `storeFields` constructor\n     * option) for the given document ID. Returns `undefined` if the document is\n     * not present in the index.\n     *\n     * @param id  The document ID\n     */\n    getStoredFields(id) {\n        const shortId = this._idToShortId.get(id);\n        if (shortId == null) {\n            return undefined;\n        }\n        return this._storedFields.get(shortId);\n    }\n    /**\n     * Search for documents matching the given search query.\n     *\n     * The result is a list of scored document IDs matching the query, sorted by\n     * descending score, and each including data about which terms were matched and\n     * in which fields.\n     *\n     * ### Basic usage:\n     *\n     * ```javascript\n     * // Search for \"zen art motorcycle\" with default options: terms have to match\n     * // exactly, and individual terms are joined with OR\n     * miniSearch.search('zen art motorcycle')\n     * // => [ { id: 2, score: 2.77258, match: { ... } }, { id: 4, score: 1.38629, match: { ... } } ]\n     * ```\n     *\n     * ### Restrict search to specific fields:\n     *\n     * ```javascript\n     * // Search only in the 'title' field\n     * miniSearch.search('zen', { fields: ['title'] })\n     * ```\n     *\n     * ### Field boosting:\n     *\n     * ```javascript\n     * // Boost a field\n     * miniSearch.search('zen', { boost: { title: 2 } })\n     * ```\n     *\n     * ### Prefix search:\n     *\n     * ```javascript\n     * // Search for \"moto\" with prefix search (it will match documents\n     * // containing terms that start with \"moto\" or \"neuro\")\n     * miniSearch.search('moto neuro', { prefix: true })\n     * ```\n     *\n     * ### Fuzzy search:\n     *\n     * ```javascript\n     * // Search for \"ismael\" with fuzzy search (it will match documents containing\n     * // terms similar to \"ismael\", with a maximum edit distance of 0.2 term.length\n     * // (rounded to nearest integer)\n     * miniSearch.search('ismael', { fuzzy: 0.2 })\n     * ```\n     *\n     * ### Combining strategies:\n     *\n     * ```javascript\n     * // Mix of exact match, prefix search, and fuzzy search\n     * miniSearch.search('ismael mob', {\n     *  prefix: true,\n     *  fuzzy: 0.2\n     * })\n     * ```\n     *\n     * ### Advanced prefix and fuzzy search:\n     *\n     * ```javascript\n     * // Perform fuzzy and prefix search depending on the search term. Here\n     * // performing prefix and fuzzy search only on terms longer than 3 characters\n     * miniSearch.search('ismael mob', {\n     *  prefix: term => term.length > 3\n     *  fuzzy: term => term.length > 3 ? 0.2 : null\n     * })\n     * ```\n     *\n     * ### Combine with AND:\n     *\n     * ```javascript\n     * // Combine search terms with AND (to match only documents that contain both\n     * // \"motorcycle\" and \"art\")\n     * miniSearch.search('motorcycle art', { combineWith: 'AND' })\n     * ```\n     *\n     * ### Combine with AND_NOT:\n     *\n     * There is also an AND_NOT combinator, that finds documents that match the\n     * first term, but do not match any of the other terms. This combinator is\n     * rarely useful with simple queries, and is meant to be used with advanced\n     * query combinations (see later for more details).\n     *\n     * ### Filtering results:\n     *\n     * ```javascript\n     * // Filter only results in the 'fiction' category (assuming that 'category'\n     * // is a stored field)\n     * miniSearch.search('motorcycle art', {\n     *   filter: (result) => result.category === 'fiction'\n     * })\n     * ```\n     *\n     * ### Wildcard query\n     *\n     * Searching for an empty string (assuming the default tokenizer) returns no\n     * results. Sometimes though, one needs to match all documents, like in a\n     * \"wildcard\" search. This is possible by passing the special value\n     * {@link MiniSearch.wildcard} as the query:\n     *\n     * ```javascript\n     * // Return search results for all documents\n     * miniSearch.search(MiniSearch.wildcard)\n     * ```\n     *\n     * Note that search options such as `filter` and `boostDocument` are still\n     * applied, influencing which results are returned, and their order:\n     *\n     * ```javascript\n     * // Return search results for all documents in the 'fiction' category\n     * miniSearch.search(MiniSearch.wildcard, {\n     *   filter: (result) => result.category === 'fiction'\n     * })\n     * ```\n     *\n     * ### Advanced combination of queries:\n     *\n     * It is possible to combine different subqueries with OR, AND, and AND_NOT,\n     * and even with different search options, by passing a query expression\n     * tree object as the first argument, instead of a string.\n     *\n     * ```javascript\n     * // Search for documents that contain \"zen\" and (\"motorcycle\" or \"archery\")\n     * miniSearch.search({\n     *   combineWith: 'AND',\n     *   queries: [\n     *     'zen',\n     *     {\n     *       combineWith: 'OR',\n     *       queries: ['motorcycle', 'archery']\n     *     }\n     *   ]\n     * })\n     *\n     * // Search for documents that contain (\"apple\" or \"pear\") but not \"juice\" and\n     * // not \"tree\"\n     * miniSearch.search({\n     *   combineWith: 'AND_NOT',\n     *   queries: [\n     *     {\n     *       combineWith: 'OR',\n     *       queries: ['apple', 'pear']\n     *     },\n     *     'juice',\n     *     'tree'\n     *   ]\n     * })\n     * ```\n     *\n     * Each node in the expression tree can be either a string, or an object that\n     * supports all {@link SearchOptions} fields, plus a `queries` array field for\n     * subqueries.\n     *\n     * Note that, while this can become complicated to do by hand for complex or\n     * deeply nested queries, it provides a formalized expression tree API for\n     * external libraries that implement a parser for custom query languages.\n     *\n     * @param query  Search query\n     * @param searchOptions  Search options. Each option, if not given, defaults to the corresponding value of `searchOptions` given to the constructor, or to the library default.\n     */\n    search(query, searchOptions = {}) {\n        const { searchOptions: globalSearchOptions } = this._options;\n        const searchOptionsWithDefaults = { ...globalSearchOptions, ...searchOptions };\n        const rawResults = this.executeQuery(query, searchOptions);\n        const results = [];\n        for (const [docId, { score, terms, match }] of rawResults) {\n            // terms are the matched query terms, which will be returned to the user\n            // as queryTerms. The quality is calculated based on them, as opposed to\n            // the matched terms in the document (which can be different due to\n            // prefix and fuzzy match)\n            const quality = terms.length || 1;\n            const result = {\n                id: this._documentIds.get(docId),\n                score: score * quality,\n                terms: Object.keys(match),\n                queryTerms: terms,\n                match\n            };\n            Object.assign(result, this._storedFields.get(docId));\n            if (searchOptionsWithDefaults.filter == null || searchOptionsWithDefaults.filter(result)) {\n                results.push(result);\n            }\n        }\n        // If it's a wildcard query, and no document boost is applied, skip sorting\n        // the results, as all results have the same score of 1\n        if (query === MiniSearch.wildcard && searchOptionsWithDefaults.boostDocument == null) {\n            return results;\n        }\n        results.sort(byScore);\n        return results;\n    }\n    /**\n     * Provide suggestions for the given search query\n     *\n     * The result is a list of suggested modified search queries, derived from the\n     * given search query, each with a relevance score, sorted by descending score.\n     *\n     * By default, it uses the same options used for search, except that by\n     * default it performs prefix search on the last term of the query, and\n     * combine terms with `'AND'` (requiring all query terms to match). Custom\n     * options can be passed as a second argument. Defaults can be changed upon\n     * calling the {@link MiniSearch} constructor, by passing a\n     * `autoSuggestOptions` option.\n     *\n     * ### Basic usage:\n     *\n     * ```javascript\n     * // Get suggestions for 'neuro':\n     * miniSearch.autoSuggest('neuro')\n     * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 0.46240 } ]\n     * ```\n     *\n     * ### Multiple words:\n     *\n     * ```javascript\n     * // Get suggestions for 'zen ar':\n     * miniSearch.autoSuggest('zen ar')\n     * // => [\n     * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n     * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n     * // ]\n     * ```\n     *\n     * ### Fuzzy suggestions:\n     *\n     * ```javascript\n     * // Correct spelling mistakes using fuzzy search:\n     * miniSearch.autoSuggest('neromancer', { fuzzy: 0.2 })\n     * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 1.03998 } ]\n     * ```\n     *\n     * ### Filtering:\n     *\n     * ```javascript\n     * // Get suggestions for 'zen ar', but only within the 'fiction' category\n     * // (assuming that 'category' is a stored field):\n     * miniSearch.autoSuggest('zen ar', {\n     *   filter: (result) => result.category === 'fiction'\n     * })\n     * // => [\n     * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n     * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n     * // ]\n     * ```\n     *\n     * @param queryString  Query string to be expanded into suggestions\n     * @param options  Search options. The supported options and default values\n     * are the same as for the {@link MiniSearch#search} method, except that by\n     * default prefix search is performed on the last term in the query, and terms\n     * are combined with `'AND'`.\n     * @return  A sorted array of suggestions sorted by relevance score.\n     */\n    autoSuggest(queryString, options = {}) {\n        options = { ...this._options.autoSuggestOptions, ...options };\n        const suggestions = new Map();\n        for (const { score, terms } of this.search(queryString, options)) {\n            const phrase = terms.join(' ');\n            const suggestion = suggestions.get(phrase);\n            if (suggestion != null) {\n                suggestion.score += score;\n                suggestion.count += 1;\n            }\n            else {\n                suggestions.set(phrase, { score, terms, count: 1 });\n            }\n        }\n        const results = [];\n        for (const [suggestion, { score, terms, count }] of suggestions) {\n            results.push({ suggestion, terms, score: score / count });\n        }\n        results.sort(byScore);\n        return results;\n    }\n    /**\n     * Total number of documents available to search\n     */\n    get documentCount() {\n        return this._documentCount;\n    }\n    /**\n     * Number of terms in the index\n     */\n    get termCount() {\n        return this._index.size;\n    }\n    /**\n     * Deserializes a JSON index (serialized with `JSON.stringify(miniSearch)`)\n     * and instantiates a MiniSearch instance. It should be given the same options\n     * originally used when serializing the index.\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * // If the index was serialized with:\n     * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n     * miniSearch.addAll(documents)\n     *\n     * const json = JSON.stringify(miniSearch)\n     * // It can later be deserialized like this:\n     * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })\n     * ```\n     *\n     * @param json  JSON-serialized index\n     * @param options  configuration options, same as the constructor\n     * @return An instance of MiniSearch deserialized from the given JSON.\n     */\n    static loadJSON(json, options) {\n        if (options == null) {\n            throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index');\n        }\n        return this.loadJS(JSON.parse(json), options);\n    }\n    /**\n     * Async equivalent of {@link MiniSearch.loadJSON}\n     *\n     * This function is an alternative to {@link MiniSearch.loadJSON} that returns\n     * a promise, and loads the index in batches, leaving pauses between them to avoid\n     * blocking the main thread. It tends to be slower than the synchronous\n     * version, but does not block the main thread, so it can be a better choice\n     * when deserializing very large indexes.\n     *\n     * @param json  JSON-serialized index\n     * @param options  configuration options, same as the constructor\n     * @return A Promise that will resolve to an instance of MiniSearch deserialized from the given JSON.\n     */\n    static async loadJSONAsync(json, options) {\n        if (options == null) {\n            throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index');\n        }\n        return this.loadJSAsync(JSON.parse(json), options);\n    }\n    /**\n     * Returns the default value of an option. It will throw an error if no option\n     * with the given name exists.\n     *\n     * @param optionName  Name of the option\n     * @return The default value of the given option\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * // Get default tokenizer\n     * MiniSearch.getDefault('tokenize')\n     *\n     * // Get default term processor\n     * MiniSearch.getDefault('processTerm')\n     *\n     * // Unknown options will throw an error\n     * MiniSearch.getDefault('notExisting')\n     * // => throws 'MiniSearch: unknown option \"notExisting\"'\n     * ```\n     */\n    static getDefault(optionName) {\n        if (defaultOptions.hasOwnProperty(optionName)) {\n            return getOwnProperty(defaultOptions, optionName);\n        }\n        else {\n            throw new Error(`MiniSearch: unknown option \"${optionName}\"`);\n        }\n    }\n    /**\n     * @ignore\n     */\n    static loadJS(js, options) {\n        const { index, documentIds, fieldLength, storedFields, serializationVersion } = js;\n        const miniSearch = this.instantiateMiniSearch(js, options);\n        miniSearch._documentIds = objectToNumericMap(documentIds);\n        miniSearch._fieldLength = objectToNumericMap(fieldLength);\n        miniSearch._storedFields = objectToNumericMap(storedFields);\n        for (const [shortId, id] of miniSearch._documentIds) {\n            miniSearch._idToShortId.set(id, shortId);\n        }\n        for (const [term, data] of index) {\n            const dataMap = new Map();\n            for (const fieldId of Object.keys(data)) {\n                let indexEntry = data[fieldId];\n                // Version 1 used to nest the index entry inside a field called ds\n                if (serializationVersion === 1) {\n                    indexEntry = indexEntry.ds;\n                }\n                dataMap.set(parseInt(fieldId, 10), objectToNumericMap(indexEntry));\n            }\n            miniSearch._index.set(term, dataMap);\n        }\n        return miniSearch;\n    }\n    /**\n     * @ignore\n     */\n    static async loadJSAsync(js, options) {\n        const { index, documentIds, fieldLength, storedFields, serializationVersion } = js;\n        const miniSearch = this.instantiateMiniSearch(js, options);\n        miniSearch._documentIds = await objectToNumericMapAsync(documentIds);\n        miniSearch._fieldLength = await objectToNumericMapAsync(fieldLength);\n        miniSearch._storedFields = await objectToNumericMapAsync(storedFields);\n        for (const [shortId, id] of miniSearch._documentIds) {\n            miniSearch._idToShortId.set(id, shortId);\n        }\n        let count = 0;\n        for (const [term, data] of index) {\n            const dataMap = new Map();\n            for (const fieldId of Object.keys(data)) {\n                let indexEntry = data[fieldId];\n                // Version 1 used to nest the index entry inside a field called ds\n                if (serializationVersion === 1) {\n                    indexEntry = indexEntry.ds;\n                }\n                dataMap.set(parseInt(fieldId, 10), await objectToNumericMapAsync(indexEntry));\n            }\n            if (++count % 1000 === 0)\n                await wait(0);\n            miniSearch._index.set(term, dataMap);\n        }\n        return miniSearch;\n    }\n    /**\n     * @ignore\n     */\n    static instantiateMiniSearch(js, options) {\n        const { documentCount, nextId, fieldIds, averageFieldLength, dirtCount, serializationVersion } = js;\n        if (serializationVersion !== 1 && serializationVersion !== 2) {\n            throw new Error('MiniSearch: cannot deserialize an index created with an incompatible version');\n        }\n        const miniSearch = new MiniSearch(options);\n        miniSearch._documentCount = documentCount;\n        miniSearch._nextId = nextId;\n        miniSearch._idToShortId = new Map();\n        miniSearch._fieldIds = fieldIds;\n        miniSearch._avgFieldLength = averageFieldLength;\n        miniSearch._dirtCount = dirtCount || 0;\n        miniSearch._index = new SearchableMap();\n        return miniSearch;\n    }\n    /**\n     * @ignore\n     */\n    executeQuery(query, searchOptions = {}) {\n        if (query === MiniSearch.wildcard) {\n            return this.executeWildcardQuery(searchOptions);\n        }\n        if (typeof query !== 'string') {\n            const options = { ...searchOptions, ...query, queries: undefined };\n            const results = query.queries.map((subquery) => this.executeQuery(subquery, options));\n            return this.combineResults(results, options.combineWith);\n        }\n        const { tokenize, processTerm, searchOptions: globalSearchOptions } = this._options;\n        const options = { tokenize, processTerm, ...globalSearchOptions, ...searchOptions };\n        const { tokenize: searchTokenize, processTerm: searchProcessTerm } = options;\n        const terms = searchTokenize(query)\n            .flatMap((term) => searchProcessTerm(term))\n            .filter((term) => !!term);\n        const queries = terms.map(termToQuerySpec(options));\n        const results = queries.map(query => this.executeQuerySpec(query, options));\n        return this.combineResults(results, options.combineWith);\n    }\n    /**\n     * @ignore\n     */\n    executeQuerySpec(query, searchOptions) {\n        const options = { ...this._options.searchOptions, ...searchOptions };\n        const boosts = (options.fields || this._options.fields).reduce((boosts, field) => ({ ...boosts, [field]: getOwnProperty(options.boost, field) || 1 }), {});\n        const { boostDocument, weights, maxFuzzy, bm25: bm25params } = options;\n        const { fuzzy: fuzzyWeight, prefix: prefixWeight } = { ...defaultSearchOptions.weights, ...weights };\n        const data = this._index.get(query.term);\n        const results = this.termResults(query.term, query.term, 1, query.termBoost, data, boosts, boostDocument, bm25params);\n        let prefixMatches;\n        let fuzzyMatches;\n        if (query.prefix) {\n            prefixMatches = this._index.atPrefix(query.term);\n        }\n        if (query.fuzzy) {\n            const fuzzy = (query.fuzzy === true) ? 0.2 : query.fuzzy;\n            const maxDistance = fuzzy < 1 ? Math.min(maxFuzzy, Math.round(query.term.length * fuzzy)) : fuzzy;\n            if (maxDistance)\n                fuzzyMatches = this._index.fuzzyGet(query.term, maxDistance);\n        }\n        if (prefixMatches) {\n            for (const [term, data] of prefixMatches) {\n                const distance = term.length - query.term.length;\n                if (!distance) {\n                    continue;\n                } // Skip exact match.\n                // Delete the term from fuzzy results (if present) if it is also a\n                // prefix result. This entry will always be scored as a prefix result.\n                fuzzyMatches === null || fuzzyMatches === void 0 ? void 0 : fuzzyMatches.delete(term);\n                // Weight gradually approaches 0 as distance goes to infinity, with the\n                // weight for the hypothetical distance 0 being equal to prefixWeight.\n                // The rate of change is much lower than that of fuzzy matches to\n                // account for the fact that prefix matches stay more relevant than\n                // fuzzy matches for longer distances.\n                const weight = prefixWeight * term.length / (term.length + 0.3 * distance);\n                this.termResults(query.term, term, weight, query.termBoost, data, boosts, boostDocument, bm25params, results);\n            }\n        }\n        if (fuzzyMatches) {\n            for (const term of fuzzyMatches.keys()) {\n                const [data, distance] = fuzzyMatches.get(term);\n                if (!distance) {\n                    continue;\n                } // Skip exact match.\n                // Weight gradually approaches 0 as distance goes to infinity, with the\n                // weight for the hypothetical distance 0 being equal to fuzzyWeight.\n                const weight = fuzzyWeight * term.length / (term.length + distance);\n                this.termResults(query.term, term, weight, query.termBoost, data, boosts, boostDocument, bm25params, results);\n            }\n        }\n        return results;\n    }\n    /**\n     * @ignore\n     */\n    executeWildcardQuery(searchOptions) {\n        const results = new Map();\n        const options = { ...this._options.searchOptions, ...searchOptions };\n        for (const [shortId, id] of this._documentIds) {\n            const score = options.boostDocument ? options.boostDocument(id, '', this._storedFields.get(shortId)) : 1;\n            results.set(shortId, {\n                score,\n                terms: [],\n                match: {}\n            });\n        }\n        return results;\n    }\n    /**\n     * @ignore\n     */\n    combineResults(results, combineWith = OR) {\n        if (results.length === 0) {\n            return new Map();\n        }\n        const operator = combineWith.toLowerCase();\n        const combinator = combinators[operator];\n        if (!combinator) {\n            throw new Error(`Invalid combination operator: ${combineWith}`);\n        }\n        return results.reduce(combinator) || new Map();\n    }\n    /**\n     * Allows serialization of the index to JSON, to possibly store it and later\n     * deserialize it with {@link MiniSearch.loadJSON}.\n     *\n     * Normally one does not directly call this method, but rather call the\n     * standard JavaScript `JSON.stringify()` passing the {@link MiniSearch}\n     * instance, and JavaScript will internally call this method. Upon\n     * deserialization, one must pass to {@link MiniSearch.loadJSON} the same\n     * options used to create the original instance that was serialized.\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * // Serialize the index:\n     * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n     * miniSearch.addAll(documents)\n     * const json = JSON.stringify(miniSearch)\n     *\n     * // Later, to deserialize it:\n     * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })\n     * ```\n     *\n     * @return A plain-object serializable representation of the search index.\n     */\n    toJSON() {\n        const index = [];\n        for (const [term, fieldIndex] of this._index) {\n            const data = {};\n            for (const [fieldId, freqs] of fieldIndex) {\n                data[fieldId] = Object.fromEntries(freqs);\n            }\n            index.push([term, data]);\n        }\n        return {\n            documentCount: this._documentCount,\n            nextId: this._nextId,\n            documentIds: Object.fromEntries(this._documentIds),\n            fieldIds: this._fieldIds,\n            fieldLength: Object.fromEntries(this._fieldLength),\n            averageFieldLength: this._avgFieldLength,\n            storedFields: Object.fromEntries(this._storedFields),\n            dirtCount: this._dirtCount,\n            index,\n            serializationVersion: 2\n        };\n    }\n    /**\n     * @ignore\n     */\n    termResults(sourceTerm, derivedTerm, termWeight, termBoost, fieldTermData, fieldBoosts, boostDocumentFn, bm25params, results = new Map()) {\n        if (fieldTermData == null)\n            return results;\n        for (const field of Object.keys(fieldBoosts)) {\n            const fieldBoost = fieldBoosts[field];\n            const fieldId = this._fieldIds[field];\n            const fieldTermFreqs = fieldTermData.get(fieldId);\n            if (fieldTermFreqs == null)\n                continue;\n            let matchingFields = fieldTermFreqs.size;\n            const avgFieldLength = this._avgFieldLength[fieldId];\n            for (const docId of fieldTermFreqs.keys()) {\n                if (!this._documentIds.has(docId)) {\n                    this.removeTerm(fieldId, docId, derivedTerm);\n                    matchingFields -= 1;\n                    continue;\n                }\n                const docBoost = boostDocumentFn ? boostDocumentFn(this._documentIds.get(docId), derivedTerm, this._storedFields.get(docId)) : 1;\n                if (!docBoost)\n                    continue;\n                const termFreq = fieldTermFreqs.get(docId);\n                const fieldLength = this._fieldLength.get(docId)[fieldId];\n                // NOTE: The total number of fields is set to the number of documents\n                // `this._documentCount`. It could also make sense to use the number of\n                // documents where the current field is non-blank as a normalization\n                // factor. This will make a difference in scoring if the field is rarely\n                // present. This is currently not supported, and may require further\n                // analysis to see if it is a valid use case.\n                const rawScore = calcBM25Score(termFreq, matchingFields, this._documentCount, fieldLength, avgFieldLength, bm25params);\n                const weightedScore = termWeight * termBoost * fieldBoost * docBoost * rawScore;\n                const result = results.get(docId);\n                if (result) {\n                    result.score += weightedScore;\n                    assignUniqueTerm(result.terms, sourceTerm);\n                    const match = getOwnProperty(result.match, derivedTerm);\n                    if (match) {\n                        match.push(field);\n                    }\n                    else {\n                        result.match[derivedTerm] = [field];\n                    }\n                }\n                else {\n                    results.set(docId, {\n                        score: weightedScore,\n                        terms: [sourceTerm],\n                        match: { [derivedTerm]: [field] }\n                    });\n                }\n            }\n        }\n        return results;\n    }\n    /**\n     * @ignore\n     */\n    addTerm(fieldId, documentId, term) {\n        const indexData = this._index.fetch(term, createMap);\n        let fieldIndex = indexData.get(fieldId);\n        if (fieldIndex == null) {\n            fieldIndex = new Map();\n            fieldIndex.set(documentId, 1);\n            indexData.set(fieldId, fieldIndex);\n        }\n        else {\n            const docs = fieldIndex.get(documentId);\n            fieldIndex.set(documentId, (docs || 0) + 1);\n        }\n    }\n    /**\n     * @ignore\n     */\n    removeTerm(fieldId, documentId, term) {\n        if (!this._index.has(term)) {\n            this.warnDocumentChanged(documentId, fieldId, term);\n            return;\n        }\n        const indexData = this._index.fetch(term, createMap);\n        const fieldIndex = indexData.get(fieldId);\n        if (fieldIndex == null || fieldIndex.get(documentId) == null) {\n            this.warnDocumentChanged(documentId, fieldId, term);\n        }\n        else if (fieldIndex.get(documentId) <= 1) {\n            if (fieldIndex.size <= 1) {\n                indexData.delete(fieldId);\n            }\n            else {\n                fieldIndex.delete(documentId);\n            }\n        }\n        else {\n            fieldIndex.set(documentId, fieldIndex.get(documentId) - 1);\n        }\n        if (this._index.get(term).size === 0) {\n            this._index.delete(term);\n        }\n    }\n    /**\n     * @ignore\n     */\n    warnDocumentChanged(shortDocumentId, fieldId, term) {\n        for (const fieldName of Object.keys(this._fieldIds)) {\n            if (this._fieldIds[fieldName] === fieldId) {\n                this._options.logger('warn', `MiniSearch: document with ID ${this._documentIds.get(shortDocumentId)} has changed before removal: term \"${term}\" was not present in field \"${fieldName}\". Removing a document after it has changed can corrupt the index!`, 'version_conflict');\n                return;\n            }\n        }\n    }\n    /**\n     * @ignore\n     */\n    addDocumentId(documentId) {\n        const shortDocumentId = this._nextId;\n        this._idToShortId.set(documentId, shortDocumentId);\n        this._documentIds.set(shortDocumentId, documentId);\n        this._documentCount += 1;\n        this._nextId += 1;\n        return shortDocumentId;\n    }\n    /**\n     * @ignore\n     */\n    addFields(fields) {\n        for (let i = 0; i < fields.length; i++) {\n            this._fieldIds[fields[i]] = i;\n        }\n    }\n    /**\n     * @ignore\n     */\n    addFieldLength(documentId, fieldId, count, length) {\n        let fieldLengths = this._fieldLength.get(documentId);\n        if (fieldLengths == null)\n            this._fieldLength.set(documentId, fieldLengths = []);\n        fieldLengths[fieldId] = length;\n        const averageFieldLength = this._avgFieldLength[fieldId] || 0;\n        const totalFieldLength = (averageFieldLength * count) + length;\n        this._avgFieldLength[fieldId] = totalFieldLength / (count + 1);\n    }\n    /**\n     * @ignore\n     */\n    removeFieldLength(documentId, fieldId, count, length) {\n        if (count === 1) {\n            this._avgFieldLength[fieldId] = 0;\n            return;\n        }\n        const totalFieldLength = (this._avgFieldLength[fieldId] * count) - length;\n        this._avgFieldLength[fieldId] = totalFieldLength / (count - 1);\n    }\n    /**\n     * @ignore\n     */\n    saveStoredFields(documentId, doc) {\n        const { storeFields, extractField } = this._options;\n        if (storeFields == null || storeFields.length === 0) {\n            return;\n        }\n        let documentFields = this._storedFields.get(documentId);\n        if (documentFields == null)\n            this._storedFields.set(documentId, documentFields = {});\n        for (const fieldName of storeFields) {\n            const fieldValue = extractField(doc, fieldName);\n            if (fieldValue !== undefined)\n                documentFields[fieldName] = fieldValue;\n        }\n    }\n}\n/**\n * The special wildcard symbol that can be passed to {@link MiniSearch#search}\n * to match all documents\n */\nMiniSearch.wildcard = Symbol('*');\nconst getOwnProperty = (object, property) => Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined;\nconst combinators = {\n    [OR]: (a, b) => {\n        for (const docId of b.keys()) {\n            const existing = a.get(docId);\n            if (existing == null) {\n                a.set(docId, b.get(docId));\n            }\n            else {\n                const { score, terms, match } = b.get(docId);\n                existing.score = existing.score + score;\n                existing.match = Object.assign(existing.match, match);\n                assignUniqueTerms(existing.terms, terms);\n            }\n        }\n        return a;\n    },\n    [AND]: (a, b) => {\n        const combined = new Map();\n        for (const docId of b.keys()) {\n            const existing = a.get(docId);\n            if (existing == null)\n                continue;\n            const { score, terms, match } = b.get(docId);\n            assignUniqueTerms(existing.terms, terms);\n            combined.set(docId, {\n                score: existing.score + score,\n                terms: existing.terms,\n                match: Object.assign(existing.match, match)\n            });\n        }\n        return combined;\n    },\n    [AND_NOT]: (a, b) => {\n        for (const docId of b.keys())\n            a.delete(docId);\n        return a;\n    }\n};\nconst defaultBM25params = { k: 1.2, b: 0.7, d: 0.5 };\nconst calcBM25Score = (termFreq, matchingCount, totalCount, fieldLength, avgFieldLength, bm25params) => {\n    const { k, b, d } = bm25params;\n    const invDocFreq = Math.log(1 + (totalCount - matchingCount + 0.5) / (matchingCount + 0.5));\n    return invDocFreq * (d + termFreq * (k + 1) / (termFreq + k * (1 - b + b * fieldLength / avgFieldLength)));\n};\nconst termToQuerySpec = (options) => (term, i, terms) => {\n    const fuzzy = (typeof options.fuzzy === 'function')\n        ? options.fuzzy(term, i, terms)\n        : (options.fuzzy || false);\n    const prefix = (typeof options.prefix === 'function')\n        ? options.prefix(term, i, terms)\n        : (options.prefix === true);\n    const termBoost = (typeof options.boostTerm === 'function')\n        ? options.boostTerm(term, i, terms)\n        : 1;\n    return { term, fuzzy, prefix, termBoost };\n};\nconst defaultOptions = {\n    idField: 'id',\n    extractField: (document, fieldName) => document[fieldName],\n    stringifyField: (fieldValue, fieldName) => fieldValue.toString(),\n    tokenize: (text) => text.split(SPACE_OR_PUNCTUATION),\n    processTerm: (term) => term.toLowerCase(),\n    fields: undefined,\n    searchOptions: undefined,\n    storeFields: [],\n    logger: (level, message) => {\n        if (typeof (console === null || console === void 0 ? void 0 : console[level]) === 'function')\n            console[level](message);\n    },\n    autoVacuum: true\n};\nconst defaultSearchOptions = {\n    combineWith: OR,\n    prefix: false,\n    fuzzy: false,\n    maxFuzzy: 6,\n    boost: {},\n    weights: { fuzzy: 0.45, prefix: 0.375 },\n    bm25: defaultBM25params\n};\nconst defaultAutoSuggestOptions = {\n    combineWith: AND,\n    prefix: (term, i, terms) => i === terms.length - 1\n};\nconst defaultVacuumOptions = { batchSize: 1000, batchWait: 10 };\nconst defaultVacuumConditions = { minDirtFactor: 0.1, minDirtCount: 20 };\nconst defaultAutoVacuumOptions = { ...defaultVacuumOptions, ...defaultVacuumConditions };\nconst assignUniqueTerm = (target, term) => {\n    // Avoid adding duplicate terms.\n    if (!target.includes(term))\n        target.push(term);\n};\nconst assignUniqueTerms = (target, source) => {\n    for (const term of source) {\n        // Avoid adding duplicate terms.\n        if (!target.includes(term))\n            target.push(term);\n    }\n};\nconst byScore = ({ score: a }, { score: b }) => b - a;\nconst createMap = () => new Map();\nconst objectToNumericMap = (object) => {\n    const map = new Map();\n    for (const key of Object.keys(object)) {\n        map.set(parseInt(key, 10), object[key]);\n    }\n    return map;\n};\nconst objectToNumericMapAsync = async (object) => {\n    const map = new Map();\n    let count = 0;\n    for (const key of Object.keys(object)) {\n        map.set(parseInt(key, 10), object[key]);\n        if (++count % 1000 === 0) {\n            await wait(0);\n        }\n    }\n    return map;\n};\nconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n// This regular expression matches any Unicode space, newline, or punctuation\n// character\nconst SPACE_OR_PUNCTUATION = /[\\n\\r\\p{Z}\\p{P}]+/u;\n\nexport { MiniSearch as default };\n//# sourceMappingURL=index.js.map\n"],"x_google_ignoreList":[0],"mappings":"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"}